# Please see the native2ascii maven plugin in the pom.xml of babyfish-parent.
badDerivedProvider                                  = 对象模型接口“{0}”非法，其使用的提供者是“{1}”，但是超类所用的对象模型接口“{2}”却使用了另外一个提供者“{3}”
badDerivedMode                                      = 对象模型接口“{0}”非法，其使用的模式是“{1}”，但是超类所用的对象模型接口“{2}”却使用了另外一个模式“{3}”
badRelatedObjectModelProvider                       = 对象模型接口“{0}”非法，其使用的提供者是“{1}”，此接口通过方法“{2}”依赖于类“{3}”， 此类内部的对象模型接口“{4}”却使用了另外一个提供者“{5}”，这是不允许的
duplicatedStaticMethodToGetOM                       = 方法“{0}”和“{1}”均被注解“@{2}”修饰，这是不允许的
methodToGetOMMustBeStatic                           = 方法“{0}”被注解“@{1}”修饰，所以它必须是静态方法
staticMethodToGetOMMustNotBeDefault                 = 方法“{0}”被注解“@{1}”修饰，所以它不能是private, protected或public，只能采用默认访问级别
badStaticMethodToGetOM                              = 方法“{0}”被注解“@{1}”修饰，所以它必须有且只有一个“{2}”类型的参数，且返回类型必须是“{3}”或“{4}”
noStaticMethodToGetOM                               = 在模型拥有类“{0}”中，必须有一个被注解“@{1}”修饰的静态方法
objectModelClassMustBeInterface                     = 对象模型类“{0}”被注解“@{1}”修饰，所以必须是一个接口
badSuperInterfaceOfObjectModel                      = 对象模型接口“{0}”非法，如果它存在超接口，则超接口必须是“{1}”
tooManyObjectModelClasses                           = 在模型拥有类“{0}”，过多的内部类型被注解“@{1}”修饰
noObjectModelClasses                                = 在模型拥有类“{0}”中必须定义一个被注解“@{1}”注解的内部接口
invalidAssociationClass                             = 关联方法“{0}”非法，其返回类型必须是“{1}”中任意一个类型
associationMethodMissGenericArguments               = 关联方法“{0}”非法，其返回类型必须执行指定泛型参数
associationMethodMustHaveNoParameters               = 关联方法“{0}”非法，它本身不能带泛型参数
associationMethodMustThrowNoExceptions              = 关联方法“{0}”非法，它不能抛出任何受查异常
associationMethodMissAnnotation                     = 关联方法“{0}”非法，它必须被注解“@{1}”修饰
invalidOppositeAssociationName                      = 关联方法“{0}”非法，它被注解“@{1}”修饰，注解指定opposite参数为“{2}”，但是在对端的对象模型接口“{3}”中不存在一个名为“{2}”的关联属性
invalidOppositeAssociationMethod                    = 关联方法“{0}”非法，它被注解“@{1}”修饰，注解指定opposite参数为“{2}”，但是在对端的对象模型接口“{3}”中名为“{2}”的关联属性并没有被“@{1}”修饰
oppositeReferenceConflict                           = 关联方法“{0}”和“{1}”都是用注解“@{2}”引用对方关联方法“{3}”，这是冲突的
invalidBidirectionalAssociations                    = 关联方法“{0}”和“{1}”不能进行双向关联配对，虽然前者通过注解“@{2}”引用了后者，但后者并不对应地引用前者
invalidAssociationEndTypePair                       = 关联方法“{0}”和“{1}”不能进行双向关联配对，因为它们的返回值类型是不允许配对的，允许配对的关联端点配对组合如下：{2}
mustHaveNoTypeParameters                            = 方法“{0}”本身不允许具备泛型参数
canNotThrowCheckedException                         = 方法“{0}”本身不允许抛出受查异常
badParameterCountOfMethod                           = 方法“{0}”必须具备0或1个参数
mustReturnVoidBecauseThereIsOneParameter            = 方法“{0}”具备一个参数，所以必须返回void
mustStartWithSet                                    = 方法“{0}”具备一个参数，所以其名称必须以set开头
mustNotReturnVoidBecauseThereIsNoParameters         = 方法“{0}”无参数，所以不能返回void
mustStartWithGetOrIs                                = 方法“{0}”无参数，所以其名称必须以is或get开头
propertyHasBeenDeclarationInSuperMetadata           = 方法“{0}”在超对象模型“{1}”已经定义过了
noGetterForScalarSetter                             = 方法“{0}”是一个标量属性的setter方法，但是不存在一个形如“{1} {2}.{3}()”的getter方法
noSetterForScalarGetter                             = 方法“{0}”是一个标量属性的getter方法，但是不存在一个形如“void {1}.{2}({3} value)”的setter方法
invalidAnnotationsOfScalarSetter                    = 方法“{0}”是一个标量属性的setter方法，因而不允许被注解修饰
conflictAnnotationAnnotations                       = 方法“{0}”上的注解“@{1}”非法，因为此注解同时被注解“@{2}”和“@{3}”注解
conflictAnnotations                                 = 方法“{0}”非法，其既被被“@{2}”修饰的注解“@{1}”修饰，又被被“@{4}”修饰的注解“@{3}”修饰
classIsNotFirstLowerTypeInScalarOnly                = 方法“{0}”的注解“@{1}”非法，此注解被“@{2}”修饰，所以其属性“{3}”只能使用类作为其第一个元素
badLowerAndUpperInScalarOnly                        = 方法“{0}”的注解“@{1}”非法，此注解被“@{2}”修饰，其属性“{3}”包含“{4}”且其属性“{5}”包含“{6}”，但“{6}”不是“{4}”的派生类型
scalarTypeOutOfLowerBound                           = 方法“{0}”非法，因为它被注解“@{1}”修饰，此注解又被注解“@{2}”修饰，通过参数“以参数“{3}”规定了“{4}”作为属性类型的下限，但是本属性类型 “{5}”并不是那个类型的派生类型
scalarTypeOutOfUpperBound                           = 方法“{0}”非法，因为它被注解“@{1}”修饰，此注解又被注解“@{2}”修饰，通过参数“以参数“{3}”规定了“{4}”作为属性类型的上限，但是本属性类型 “{5}”并不是那个类型的祖先类型
associatedEndpointTypeOutOfBound                    = 关联方法“{0}”非法，因为它被注解“@{1}”修饰，此注解又被注解“@{2}”修饰，通过参数“{3}”规定了本关联的关联端点类型必须是“{4}”之一，但本关联属性的关联端点类型“{5}”不属于其中任何一个
propertyIsNeigthScalarNorAssociation                = 方法“{0}”非法，它必须被一个被“@{1}”或“@{2}”修饰的注解所修饰
noAssociationAnnotationForAssociationProperty       = 方法“{0}”非法，如果它被某个被注解“@{2}”修饰的注解所修饰，那么它同时也必须被注解“@{1}”所修饰
objectModelComparatorPropertiesAreDuplicated        = 对象模型接口“{0}”非法，它已经通过注解“@{1}”声明了键属性集合“{2}”，但其中键属性名“{3}”重复
noComparatorForSortedSet                            = 对象模型接口“{1}”的关联属性“{0}”非法，它的返回值兼容“{2}”类型，但是在这个关联属性或对方ObjectModel接口“{4}”上，并没有注解“@{3}”或此注解未指定任何属性值
objectModelKeyPropertyIsNotExisting                 = 对象模型接口“{0}”非法，它已经通过注解“@{1}”声明了键属性集合“{2}”，但其中键属性名“{3}”未对应到任何属性
objectModelKeyPropertyIsNotScalar                   = 对象模型接口“{0}”非法，它已经通过注解“@{1}”声明了键属性集合“{2}”，但其中键属性名“{3}”并非标量属性
objectModelKeyPropertyIsDeferrable                  = 对象模型接口“{0}”非法，它已经通过注解“@{1}”声明了键属性集合“{2}”，但其中键属性名“{3}”被注解“@{4}”修饰
objectModelKeyPropertyHasBadType                    = 对象模型接口“{0}”非法，它已经通过注解“@{1}”声明了键属性集合“{2}”，但其中键属性名“{3}”的类型为“{4}”
associationComparatorPropertiesAreDuplicated        = 对象模型接口“{1}”的关联方法“{0}”非法，它已经通过注解“@{2}”声明了键属性集合“{3}”，但是其中键属性名“{4}”重复
associationKeyPropertyIsNotExisting                 = 对象模型接口“{1}”的关联方法“{0}”非法，它已经通过注解“@{2}”声明了键属性集合“{3}”，但是其中键属性名“{4}”在对方对象模型接口“{5}”中未对应到任何属性
associationKeyPropertyIsNotScalar                   = 对象模型接口“{1}”的关联方法“{0}”非法，它已经通过注解“@{2}”声明了键属性集合“{3}”，但是其中键属性名“{4}”在对方对象模型接口“{5}”中并非标量属性
associationKeyPropertyIsDeferrable                  = 对象模型接口“{1}”的关联方法“{0}”非法，它已经通过注解“@{2}”声明了键属性集合“{3}”，但是其中键属性名“{4}”在对方对象模型接口“{5}”中是一个被注解“@{6}”修饰的属性
associationKeyPropertyHasBadType                    = 对象模型接口“{1}”的关联方法“{0}”非法，它已经通过注解“@{2}”声明了键属性集合“{3}”，但是其中键属性名“{4}”在对方对象模型接口“{5}”中是一个类型为“{6}”的属性
specifiedPropertyIsNotScalarProperty                = 在对象模型接口“{0}”中，id为{1}的属性并非标量属性
specifiedPropertyIsNotAssociationProperty           = 在对象模型接口“{0}”中，id为{1}的属性并非关联属性
noProperty                                          = 在对象模型接口“{0}”中，不存在名称为“{1}”的属性
noScalarProperty                                    = 在对象模型接口“{0}”中，不存在名称为“{1}”的标量属性
noAssociationProperty                               = 在对象模型接口“{0}”中，不存在名称为“{1}”的关联属性
propertyNameCanNotBeAnyOf                           = 对象模型接口中的属性名不能是“{0}”之一
bothAssociationOnlyAndContravariance                = 关联方法“{0}”非法，它不能同时被注解“@{1}”和“@{2}”修饰
associationCanNotBeView                             = 关联方法“{0}”非法，其返回类型不能是“{1}”
associationMustBeAnyOf                              = 关联方法“{0}”非法，其返回值必须是“{1}”之一
propertyMustMarkedByContravariance                  = 方法“{0}”必须被注解“{1}”修饰
mustHaveSuperObjectModel                            = 对象模型接口“{0}”包含一个被注解“@{2}”修饰的方法“{1}”，但其模型拥有类却不以另外一个模型拥有类为超类
noBaseProperty                                      = 关联方法“{0}”非法，它被注解“@{1}”修饰且参数被指定为“{2}”，但在超对象模型“{3}”中却没有名称为“{2}”的关联属性
invalidBasePropertyType                             = 关联方法“{0}”非法，它被注解“@{1}”修饰且参数被指定为“{2}”，但在超对象模型中名称为“{3}”的关联属性的类型却不是“{4}”
invalidBasePropertyKeyType                          = 关联方法“{0}”非法，它被注解“@{1}”修饰且参数被指定为“{2}”，但在超对象模型中却没有名称为“{2}”的属性，这个关联的Java类型是“{3}”并且使用了“{4}”作为其键类型，但是在超对象模型接口“{5}”中名称为“{2}”的关联属性的键类型却为“{6}”
invalidBasePropertyElementType                      = 关联方法“{0}”非法，它被注解“@{1}”修饰且参数被指定为“{2}”，它返回的集合的元素类型是“{3}”，但是在超对象模型接口“{4}”中名称为“{2}”的关联属性的元素类型却为“{5}”，这并非“{3}”的祖先类型
ownerMustBeReference                                = 方法“{0}”非法，它被注解“@{1}”修饰，而此注解又被“@{2}”修饰，所以当前对象模型接口的模式需要为“{3}”，但其实是“{4}”
propertyMustNotBeDeferrable                         = 方法“{0}”非法，它被注解“@{1}”修饰，而此注解又被“@{2}”修饰，所以当前方法不能被“@{3}”修饰
scalarCanNotBeReference                             = 对象模型接口“{0}”非法，其标量属性“{1}”不能返回采用模式为“{2}”的对象模型的类
noDisabilityInSuperObjectModel                      = 对象模型接口“{0}”非法，它被注解“@{1}”修饰，但其超对象模型接口“{2}”却没有被之修饰
invalidTypeLevelReferenceComparasionRule            = 对象模型接口“{0}”非法，其模式为“{1}”所以不能被注解“@{2}”修饰
invalidTypeLevelReferenceComparasionRuleValue       = 对象模型接口“{0}”非法，它被注解“{1}”修饰以参数“{2}”修饰，但是此参数并不符合正则表达式“{3}”
invalidPropertyLevelReferenceComparasionRuleValue   = 关联属性“{0}”非法，它被注解“{1}”修饰以参数“{2}”修饰，但是此参数并不符合正则表达式“{3}”
requireEmbeddableComparasionRule                    = 对象模型接口“{0}”非法，它被模式是“{1}”所以其注解参数“{2}”必须被指定
invalidEmbeddableComparasionRule                    = 对象模型接口“{0}”非法，其注解参数“{1}”的值为“{2}”，但是此参数不符合正则表达式“{3}”
invalidEmbeddablePropertyCount                      = 对象模型接口“{0}”非法，其注解参数“{1}”指定了{2}个属性，但此接口自己定义的属性个数却为“{3}”
invalidEmbeddableComparasionPropertyName            = 对象模型接口“{0}”非法，其注解参数“{1}”指定了名称为“{2}”的属性，但此属性不存在
referenceDoesNotSupportDefaultComparator            = 不能基于对象模型接口“{0}”的元数据调用方法“{1}”，因为其模式为“{2}”
scalarCanNotReturnAbstractObjectModel               = 标量属性“{0}”返回“{1}”类，该类以“{2}”作为其对象模型接口，但此对象模型接口的模式为“{3}”
complexScalarCanNotBeDeferrable                     = 标量属性“{0}”返回使用其它对象模型模式的类，所以不能被注解“@{1}”修饰
keyTypeMustBeEmbeddable                             = 关联属性“{0}”的键类型为“{1}”，该键使用“{2}”作为其对象模型接口，其期望模式是“{3}”，但实际上却是“{4}”
oppositeOwnwerTypeMustBeReference                   = 关联属性“{0}”的引用类型为“{1}”，该类型使用“{2}”作为其对象模型接口，其期望模式是“{3}”，但实际上却是“{4}”
keyTypeMustBeClass                                  = 关联属性“{0}”的键类型是“{1}”，这不是一个类
keyTypeMustBeObjectModelOwnerClass                  = 关联属性“{0}”的键类型是“{1}”，这不是一个使用了对象模型的类
relatedTypeMustBeClass                              = 属性“{0}”返回的类型“{1}”不是一个类
relatedTypeMustBeObjectModelOwnerClass              = 属性“{0}”返回的类型“{1}”不是一个使用了对象模型的类
onlyReferenceCanMissOpposite                        = 关联方法“{0}”非法，它被注解“@{1}”修饰但没有指定opposite参数，这种单向关联仅仅允许用于返回类型为的“{2}”的方法
deferrablePropertyCanNotBeComparatorField           = 属性“{0}”被注解“@{1}”修饰，所以，它不能作为“{2}”的计算字段
badTypescalarPropertyCanNotBeComparatorField        = 属性“{0}”的类型为“{1}”，所以，它不能作为“{2}”的计算字段
deferrablePropertyRequiredReferenceModel            = 标量属性“{0}”被注解“@{1}”修饰，所以要求其所在的对象模型接口的模式为“{2}”，而事实上模式是“{3}”
unstablePropertyRequiredReferenceModel              = 标量属性“{0}”的类型是“@{1}”，所以要求其所在的对象模型接口的模式为“{2}”，而事实上模式是“{3}”
