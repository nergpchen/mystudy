# Please see the native2ascii maven plugin in the pom.xml of babyfish-parent.
unidirectionalAssociationCanNotBeInverse            = 关联方法“{0}”非法，因为它是单向关联，所以不能被注解“@{1}”修饰
tooManyInverseAnnotations                           = 关联方法“{0}”和“{1}”均被注解“@{2}”修饰，这是不允许的，必须一个被修饰另外一个不被修饰
noInverseAnnotation                                 = 关联方法“{0}”和“{1}”均没有被注解“@{2}”修饰，这是不允许的，必须一个被修饰另外一个不被修饰
conflictScalarAnnotation                            = 非法的JPA对象模型接口“{0}”，其属性方法“{1}”同时被注解“@{2}”和“@{3}”修饰，这是不允许的
entityIdHasBeenDeclaredInSuperMetadata              = 非法的JPA对象模型接口方法“{0}”，因为其所在对象模型接口具备超对象模型接口“{2}”，所以不能被注解“@{1}”修饰
duplicatedEntityIdAnnotation                        = 非法的JPA对象模型接口“{0}”，属性方法“{1}”和“{2}”都被注解“@{3}”修饰，这是不允许的
noEntityIdAnnotation                                = 非法的JPA对象模型接口“{0}”，没有任何一个方法被注解“@{1}”修饰
entityIdIsPrimitive                                 = 非法的JPA对象模型接口“{0}”，其属性方法“{1}”被注解“@{2}”修饰，故其返回类型不能基本类型
optimisticLockHasBeenDeclaredInSuperMetadata        = 非法的JPA对象模型接口方法“{0}”，因为其所在对象模型接口具备超对象模型接口“{2}”已经具备被“@{1}”修饰的属性，所以该方法不能被注解“@{1}”修饰
duplicatedOptimisticLockAnnotation                  = 非法的JPA对象模型接口“{0}”，属性方法“{1}”和“{2}”都被注解“@{3}”修饰，这是不允许的
illegalEntityName                                   = 不存在的JPA实体类“{0}”
duplicatedJAPPropertyMapping                        = 在JPA对象模型接口“{0}”中，属性“{1}”和“{2}”都被注解“@{3}”修饰并且应用了相同的参数“{4}”，这是冲突的
duplicatedJAPPropertyMappings                       = 在JPA对象模型接口“{0}”中，属性“{1}”被注解“@{2}”修饰，属性“{3}”被注解“@{4}”修饰，两处注解应用了相同的参数“{5}”，这是冲突的
noOwnerScalarProperty                               = JPA对象模型接口标量属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中并没有对应的JPA属性“{2}”
ownerScalarPropertyIsStatic                         = JPA对象模型接口标量属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”是静态的
ownerScalarPropertyMissGetterOrSetter               = JPA对象模型接口标量属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”不同时具备getter和setter
ownerScalarPropertyReturnIllegalType                = JPA对象模型接口标量属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型并非期望的“{4}”而是“{5}”
noOwnerAssociationProperty                          = JPA对象模型接口关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中并没有对应的JPA属性“{2}”
ownerAssociationPropertyIsStatic                    = JPA对象模型接口关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”是静态的
ownerAssociationPropertyMissGetter                  = JPA对象模型接口关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”不具备getter
ownerReferencePropertyReturnIllegalType             = JPA对象模型接口引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型并非期望的“{4}”而是“{5}”
ownerReferencePropertyMissSetter                    = JPA对象模型接口引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”并不具备setter
ownerCollectionPropertyMustReturnParameterizedType  = JPA对象模型接口集合关联属性“{0}”返回类型为java.util.List，且被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型并不返回java.util.List
ownerCollectionPropertyMustReturnParameterizedType  = JPA对象模型接口集合关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型并非泛型类型
ownerCollectionPropertyReturnIllegalType            = JPA对象模型接口集合关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型并非“{4}”或其超类型，而是“{5}”
ownerCollectionPropertyReturnNotAllowedType         = JPA对象模型接口集合关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，由于JPA技术的特殊性，JPA实体类“{3}”中对应的JPA属性“{2}”的类型只允许是“{4}”，而不是“{5}”或其超类型
ownerCollectionPropertyReturnIllegalElementType     = JPA对象模型接口集合关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型的最后一个泛型参数并非期望的“{4}”而是“{5}”
ownerCollectionPropertyReturnIllegalKeyType         = JPA对象模型接口集合关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型的第一个泛型参数并非期望的“{4}”而是“{5}”
noOwnerIndexProperty                                = JPA对象模型接口索引化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中并没有对应的JPA属性“{2}”
ownerIndexPropertyIsStatic                          = JPA对象模型接口索引化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”是静态的
ownerIndexPropertyMissGetterOrSetter                = JPA对象模型接口索引化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”没有getter或setter
ownerIndexPropertyReturnIllegalType                 = JPA对象模型接口索引化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”德行并非int而是“{4}”
noOwnerKeyProperty                                  = JPA对象模型接口键化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中并没有对应的JPA属性“{2}”
ownerKeyPropertyIsStatic                            = JPA对象模型接口键化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”是静态的
ownerKeyPropertyMissGetterOrSetter                  = JPA对象模型接口键化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”缺少getter或setter
ownerKeyPropertyReturnIllegalType                   = JPA对象模型接口键化引用关联属性“{0}”被注解“@{1}”带上参数“{2}”修饰，但是在JPA实体类“{3}”中对应的JPA属性“{2}”的类型并非“{4}”而非“{5}”
lazyRowLimitMustBeGEZero                            = JPA对象模型接口关联属性“{0}”被注解“@{1}”修饰，但其参数“rowLimit”非法，其值必须大于或等于0
lazyCountLimitMustBeGEZero                          = JPA对象模型接口关联属性“{0}”被注解“@{1}”修饰，但其参数“countLimit”非法，其值必须大于或等于0
lazyCountLimitMustBeLElazyRowLimit                  = JPA对象模型接口关联属性“{0}”被注解“@{1}”修饰，但她是非法的，参数“countLimit”必须小于或等于参数“rowLimit”
lazyBehaviorCanOnlyBeUsedOnInverseProperty          = JPA对象模型接口关联属性“{0}”被注解“@{1}”修饰，这是不允许的，因为该属性并非inverse属性
contravarianceMustBeMappedAsTransient               = JPA对象模型接口关联属性“{0}”被注解“@{1}”修饰，所以其对应的JPA属性“{2}”必须被“@{3}”修饰
contravarianceCanNotBeUsedWith                      = JPA对象模型接口关联属性“{0}”被注解“@{1}”修饰，不能再被“@{2}”修饰
