# Please see the native2ascii maven plugin in the pom.xml of babyfish-parent.
conflictAccessTypes                             = 属性“{0}.{1}”非法，它定义了彼此冲突的“{2}”
typeArgumentMustBeClass                         = 属性“{0}.{1}”非法，其类型“{2}”的范型参数{3}不是类
emptyJonColumnName                              = 属性“{0}.{1}”非法，其注解“@{2}”没有指定参数“name”
emptyJoinColumns                                = 属性“{0}.{1}”非法，它使用了注解“@{2}”却没有使用注解“@{3}”
illegalJoinColumnOnMultipColumns                = 属性“{0}.{1}”非法，其使用注解“@{2}”引用另外一个类“{3}”但是此类的id属性“{4}”确实一个拥有多列的内嵌类型
canNotUseMappedByWith                           = 属性“{0}.{1}”非法，其注解“@{2}”指定了参数“mappedBy”，此用法在当其同时使用注解“@{3}”时是不允许的
annotationRequiresAnyOneType                    = 属性“{0}.{1}”非法，它使用了注解“@{2}”，所以其类型必须为“{3}”之一
annotationCanOnlyBeUsedWith                     = 属性“{0}.{1}”非法，它不能使用注解“@{2}”，因为它没有同时使用以下注解之一：“{3}”
inverseCollectionMustUseMappedBy                = 属性“{0}.{1}”非法，应对对于集合属性而言，要想成为镜像端，唯一的办法是在关联注解“{2}”上使用参数“mappedBy”
implicitInverseMustBeDifferent                  = 属性“{0}.{1}”非法，其镜像性为{2}，而对端的属性“{3}.{4}”的镜像性也为“{5}”
canNotCollectInverse                            = 属性“{0}.{1}”非法，在ObjectModel4JPA中，连接配置“{2}”的所有insertable和updatable参数必须相同
unidirectionalCanNotBeCollection                = 属性“{0}.{1}”非法，在ObjectModel4JPA中，仅引用关联可以是单向的
conflictBidirectionalAssociation                = 属性“{0}.{1}”以参数“mappedBy = {3}”使用注解“@{2}”试图和“{4}.{3}”配对以建立双向关联，但是后者已经和“{5}.{6}”配对
targetOfMappedByCanNotUseMappedBy               = 属性“{0}.{1}”以参数“mappedBy = {3}”使用注解“@{2}”试图和“{4}.{3}”配对以建立双向关联，但是对方属性的注解“@{5}”同样具备参数“mappedBy”
mappedByOwnerIsWrong                            = 属性“{0}.{1}”以参数“mappedBy = {3}”使用注解“@{2}”试图和“{4}.{3}”配对以建立双向关联，但是对方属性并不引用当前属性所在的类
mappedByIsNotAssociation                        = 属性“{0}.{1}”以参数“mappedBy = {3}”使用注解“@{2}”试图和“{4}.{3}”配对以建立双向关联，但是对方属性并非关联属性
unknownMappedBy                                 = 属性“{0}.{1}”以参数“mappedBy = {3}”使用注解“@{2}”试图和“{4}.{3}”配对以建立双向关联，但是对方类并不包含此属性
illlegalRelatedOrderColumnType                  = 属性“{0}.{1}”以参数“{3}”使用注解“@{2}”指定列表索引列名，但是对方类“{4}”中列名为“{3}”的属性并不是int类型
unknownRelatedOrderColumn                       = 属性“{0}.{1}”以参数“{3}”使用注解“@{2}”指定列表索引列名，且其主注解“@{4}”的参数“{5}”已经被指定，但是对方类“{6}”中列名为“{3}”的属性并不存在
illlegalRelatedMapKeyColumnType                 = 属性“{0}.{1}”以参数“{3}”使用注解“@{2}”指定映射键列名，但是对方类“{4}”中列名为“{3}”的属性的类型并不是所期望的“{5}”而是是“{6}”
unknownRelatedMapKeyColumn                      = 属性“{0}.{1}”以参数“{3}”使用注解“@{2}”指定映射键列名，且其主注解“@{4}”的参数“{5}”已经被指定，但是对方类“{6}”中列名为“{3}”的属性并不存在
illlegalRelatedMapKeyType                       = 属性“{0}.{1}”以参数“{3}”使用注解“@{2}”指定映射键属性，但是对方类“{4}”中名称为“{3}”的属性的类型并不是所期望的“{5}”而是是“{6}”
relatedMapKeyMustBe                             = 属性“{0}.{1}”以参数“{3}”使用注解“@{2}”指定映射键属性，但是对方类“{4}”中名称为“{3}”的属性并没有使用这些注解之一：“{5}”
unknownRelatedMapKey                            = 属性“{0}.{1}”以参数“{3}”使用注解“@{2}”指定映射键属性，但是对方类“{4}”中名称为“{3}”的属性并不存在
listRequiresOrderColumnValueInObjectModel4JPA   = 属性“{0}.{1}”非法，其注解“@{2}”缺少参数，这在ObjectModel4JPA中是不允许的
listRequiresOrderColumnInObjectModel4JPA        = 属性“{0}.{1}”非法，其类型为“{2}”但不使用注解“@{3}”，这在ObjectModel4JPA中是不允许的
relatedClassMustBeEntity                        = 属性“{0}.{1}”非法，它使用注解“@{2}”引用另外一个类型“{3}”，但那个类并未使用注解“@{4}”
conflictAnnotations                             = 属性“{0}.{1}”非法，不能同时使用注解“@{2}”和“@{3}”
annotationIsNotSupportedInObjectModel4JPA       = 属性“{0}.{1}”非法，不能使用注解“{2}”，这在ObjectModel4JPA中不被支持
collectionMustBeGenericType                     = 属性“{0}.{1}”非法，它使用了注解“@{2}”但却不是范型类型，这在ObjectModel4JPA中不被允许
badCollectionType                               = 属性“{0}.{1}”非法，它使用了注解“@{2}”，所以其类型必须是以下之一：“{3}”
typeDescriptorMustBeClass                       = 属性“{0}.{1}”引用了另外一个不是用户自定义的类型“{2}”
canNotOverrideDeepProperties                    = 属性“{0}.{1}”使用注解“@{2}”企图覆盖内嵌类型“{3}”中的某些属性，但无法覆盖一下这些不存在的属性“{4}”
incongruousJPAObjectInstrument                  = 属性“{0}.{1}”引用了另外一个类型“{2}”，当前前类和此类无法协同工作，因为一个使用了注解“@{3}”而另外一个却没有
embeddedTyepIsNotEmbeddable                     = 属性“{0}.{1}”非法，它使用注解“@{2}”引用另外一个类型“{3}”，但那个类并未使用注解“@{4}”
unknownRelatedClass                             = 属性“{0}.{1}”非法，它使用注解“@{2}”引用另外一个类型“{3}”，但那时一个不存在的类型
embeddedCircular                                = 属性“{0}.{1}”非法，它使用注解“@{2}”引用内嵌类型，但发现内嵌类型应用环：“{3}”
unknownAccessType                               = 属性“{0}.{1}”非法，因为冲突配置导致其“{2}”值无法确定
badFieldAnnotation                              = 属性“{0}.{1}”的访问模式为“{2}”，所以不能在其对应的字段上使用任何JPA相关注解
noPropertyMethod                                = 属性“{0}.{1}”的访问模式为“{2}”，但是找不到其所对应的方法
badMethodAnnotation                             = 属性“{0}.{1}”的访问模式为“{2}”，所以不能在其对应的方法上使用任何JPA相关注解
noPropertyField                                 = 属性“{0}.{1}”的访问模式为“{2}”，但是找不到其所对应的字段
contravarianceRequiresSuperMetaClass            = 属性“{0}.{1}”非法，它被注解“@{2}”修饰，但是其所属类并没有遵循ObjectModel4JPA的超类
noCovarianceProperty                            = 属性“{0}.{1}”非法，它被参数为“{3}”的注解“@{2}”修饰，但是在其超类“{4}”或其祖先类中并无属性“{3}”
covariancePropertyMustBeAssociation             = 属性“{0}.{1}”非法，它被参数为“{3}”的注解“@{2}”修饰，但是协变属性“{4}.{3}”并不是关联属性
illegalCovariancePropertyType                   = 属性“{0}.{1}”非法，它被参数为“{3}”的注解“@{2}”修饰且其类型为“{5}”，但是协变属性“{4}.{3}”的类型却是“{6}”
mustNotBeEager                                  = 属性“{0}.{1}”非法，其抓取类型为"{2}"但是其所在类“{0}”的注解“{3}”的参数“{4}”为false。你有两个选择：（1）将此属性的抓取属性改为“{5}”（2）将那个注解的参数“{4}”改为true
